---
title: "Concepts"
linkTitle: "Concepts"
weight: 3
description: >
  Kuestaのコンセプト、アーキテクチャ、その他の技術関連情報について
---

## CUEを用いた Network Configuration as Code

Kuestaは、複雑なネットワーク装置のコンフィグを抽象化し、ユーザのインテントを簡単に記述できる高レベルのデータモデルとAPIを公開することをサポートします。ネットワーク装置のデータモデルは、数多のネットワーキング機能を提供するために詳細かつ複雑であり、Infrastructure as Codeのリソースモデルとして扱うには適していません。ユーザのインテントを簡単に表現できるデータモデルを提供するためには、複雑さを隠蔽しわかりやすく抽象化した高レベルなデータモデルが必要です。加えて、E2E接続のようなドメイン全体を抽象化したモデルを実現するには、複数のネットワーク装置をまたいで設定を行うデータモデルが必要になります。

このような上位モデルへの抽象化を行うと、上位モデルから低レベルな装置コンフィグへのデータマッピングは非常に複雑になります。
上位モデルと下位モデルは多対多の関係性を持つため、データマッピングに加えてデータの合成も同時に行う必要があります。このとき、データの欠損や競合、データ制約違反を起こさないように配慮しなければなりません。
Python/Jinjaを用いたシンプルなテキストテンプレートのアプローチでは、この複雑な問題を解くのは困難です。

Kuestaでは、上位モデルから下位モデルへのデータマッピングロジックを記述するプログラミング言語として[CUE](https://github.com/cue-lang/cue) を採用しています。
CUEは、データの合成と検証に強みを持つコンフィグ記述言語であり、次のような理由から上記のユースケースに適しています。
- CUEは、複数のドキュメントツリーを任意の階層で統一することを可能にします。CUEは、交換律と結合律を満たし、冪等な演算が可能という特徴があり、データを合成する順序によらず、必ず同じ結果になるように設計されています。
- CUEは、型と値を同一のものとして扱います。型とデータ制約も値の一種であり、両者の違いは具体的な値を持つか否かだけです。この新しいアプローチにより、コンフィグを記述するのと同時にスキーマとデータ制約と記述でき、シンプルかつ効率的に扱えます。
- CUEは高いプログラマビリティを有しており、テンプレート化やモジュール化といったソフトウェアコーディングのプラクティスをサポートしています。汎用的な言語を使うのと同じようなメリットが得られます。

CUEの詳細についてより知りたければ、["cuelang.org"](https://cuelang.org/docs/about/) を参照してください。


## GitOps

Kuestaは、ネットワーク装置コンフィグのためのGitOpsを提供します。ネットワーク全体のコンフィグを宣言的に記述し、Gitリポジトリでバージョン管理し、信頼できる唯一の情報源(Single Source of Truth: SSoT) とすることを目的としています。
コンフィグ設定プロセスは完全に自動化されており、Gitリポジトリのバージョンを指定することで、そのバージョンのコンフィグがネットワーク装置に自動で設定されます。
ネットワークの構成切り替えやロールバックをするには、GitブランチのHEADをデプロイしたいバージョンに変更するだけです。

Kuestaは、以下の理由からPullベースのアプローチを選択しています。
- ネットワーク装置の設定が更新されるたびに、バージョン指定されたデプロイされるべき設定と、実際のネットワーク装置の設定との間のずれを検出するため。
- SSoTのGitリポジトリに保存されているネットワーク全体のコンフィグが、あらかじめ整備されたデプロイパイプラインにより画一的に設定されることで、コンフィグの加工処理を挿入することなくネットワーク装置にデプロイされることを保証するため。
- すべてのネットワーク装置のクレデンシャルが集約されることで設定システムの権限が過度に強力になり、セキュリティリスクが高まるのを避けるため。Kuestaではネットワーク装置のクレデンシャルはKubernetes Secretリソースとして保存されるため、ExternalSecrets OperatorなどのOSSツールを使ってパブリッククラウドのSecretManagerと統合し、セキュアにこれらのクレデンシャルを管理することができます。

GitOpsの詳細については、 ["What is GitOps?"](https://www.gitops.tech/#what-is-gitops) をご覧ください。


## Kubernetesカスタムオペレータ

Kuestaは、Infrastructure as Codeを実現するエンジンとして、Kubernetesの「Reconciliation loop」と「Operatorパターン」を使用しています。
Kubernetesはコンテナのオーケストレーションツールとして有名ですが、あらゆる外部リソースのデプロイを自動化するために拡張することができます。ネットワーク装置も例外ではありません。
Kuestaは、複数のKubernetesカスタムオペレータで構成されており、それぞれGitOpsを行うためのエンジン、マルチデバイス間の分散トランザクションコーディネータ、ネットワーク装置を設定するためのドライバなどの役割を担っています。

新しいベンダーのデバイスや新しいバージョンのネットワーク装置をKuestaでサポートしたい場合は、対応するKubernetesカスタムオペレータを開発することで実現できます。


## Kuestaのコンポーネント

Kuestaは以下のコンポーネントから構成されています。

- **kuesta-server** は、KuestaのコアとなるAPIサーバです。外部のサードパーティシステムと連携するためにgNMIを公開し、上位モデルから下位モデルへのデータマッピングとデータ合成を行い、GitOpsのために新しいGitコミットを作成やプルリクエストの発行などを行います。

- **kuesta-aggregator** は、ネットワーク装置の実際のコンフィグの変更を集約し、Gitコミットを作成して、設定変更の履歴をGitレポジトリに永続化します。

- **FluxCD source-controller** は、`GitRepository` Kubernetesカスタムリソースで指定されたGitリポジトリにおけるマニフェストの変更を検出します。

- **kuesta-provisioner** は、`gitrepository-watcher` コントローラと `DeviceRollout` Kubernetesカスタムリソースで構成されています。 `gitrepository-watcher` は `GitRepository` の状態を監視してマニフェストの変更を検出し、変更が検出されると `DeviceRollout` のステータスをランニングに更新し、ネットワーク装置のコンフィグ更新のトランザクションをトリガします。

Kuestaを使用してネットワーク装置に設定をするには、対象となるネットワーク装置に設定を行うためのKubernetesカスタムオペレータを独自に用意する必要があります。Kubernetesカスタムオペレータを開発する際は、強力なフレームワークである [kubebuilder](https://github.com/kubernetes-sigs/kubebuilder) を使用することがお勧めです。
また、["Getting started"](/docs/getting-started) で使用した [device-operator](https://github.com/nttcom/kuesta/tree/main/device-operator) は、OpenConfig/gNMIデバイスを設定するために設計されたKubernetesカスタムオペレータのサンプルであり、これをベースに開発を始めることも可能です。この開発でもkubebuilderが使用されています。
